[
  {
    "name": "Equality",
    "comment": "\nA module providing primitives for proving type equalities.\n\nType equality is stronger than type equivalence.\nWith equivalence, we assert that there is some way to get from one type to the other (and back again).\nWith equality, we assert that there is exactly one type we're even talking about!\n\n@docs Equal, refl, symm, trans, inj, symmInj, cast, symmCast\n\n# Example\n\nThe [Equivalence example][] left a bad taste at the end with the realization that we weren't able to protect the generation of the view at compile time.\nFortunately all is not lost.\nWe can use a type very similar to [Equiv a b][], and not export its constructor.\nThen, a malicious user cannot attempt to create their own \"proof\" ad-hoc.\n\n[Equal a b][] is just such a type.\nLet's start by replacing all occurrences of [Equiv a b][] with [Equal a b][]:\n\n```elm\ntype Model permissions\n  = ModelUser (Equal permissions User) { name : String }\n  | ModelMod (Equal permissions Mod) { name : String }\n  | ModelAdmin (Equal permissions Admin) { name : String }\n```\n\nWe have a very similar API, so we can reuse the function [refl][] when creating `modelUser` and friends.\n\nWhen we go to dispatch on the proofs, we can't destructure so we use [cast][] and [symmCast][] instead.\n\n```elm\nview : Model permissions -> Html permissions\nview model =\n  case model of\n    ModelUser proof record ->\n      Html.App.map (symmCast proof) (viewUser Comment)\n\n    ModelMod proof record ->\n      Html.App.map (symmCast proof) (viewMod Warn)\n\n    ModelAdmin proof record ->\n      Html.App.map (symmCast proof) (viewAdmin Delete)\n```\n\nThat's it!\n\nNow, if a malicious user tries to use `viewAdmin` in the `ModelMod` case, we get a compile time error!\nFinally, we have elm helping us in a way that is even more productive than before!\nAlso, If we attempt to use any view at the top level (like in `main`), then the top level will only work for a certain permission level.\nLike if we wanted to use `viewUser` at the top level, then the model could only work for `Model User`, and the current update would not typecheck at all!\n\nIf removing whole classes of bugs isn't pragmatic, I don't know what is.\n\nLet's see it all together for completeness sake:\n\n```elm\ntype User\n  = Comment\n\ntype Mod\n  = Warn\n\ntype Admin\n  = Delete\n\ntype Model permissions\n  = ModelUser (Equal permissions User) { name : String }\n  | ModelMod (Equal permissions Mod) { name : String }\n  | ModelAdmin (Equal permissions Admin) { name : String }\n\nmodelUser : String -> Model User\nmodelUser name =\n  ModelUser refl { name = name }\n\nmodelMod : String -> Model Mod\nmodelMod name =\n  ModelMod refl { name = name }\n\nmodelAdmin : String -> Model Admin\nmodelAdmin name =\n  ModelAdmin refl { name = name }\n\nview : Model permissions -> Html permissions\nview model =\n  case model of\n    ModelUser proof record ->\n      Html.App.map (symmCast proof) (viewUser Comment)\n\n    ModelMod proof record ->\n      Html.App.map (symmCast proof) (viewMod Warn)\n\n    ModelAdmin proof record ->\n      Html.App.map (symmCast proof) (viewAdmin Delete)\n\nviewUser : User -> Html User\nviewUser Comment =\n  text \"Welcome friend!\"\n\nviewMod : Mod -> Html Mod\nviewMod Warn =\n  button [ onClick Warn ]\n    [ text \"Warn all users\" ]\n\nviewAdmin : Admin -> Html Admin\nviewAdmin Delete =\n  button [ onClick Delete ]\n    [ text \"Delete all users\" ]\n```\n\n[cast]: http://package.elm-lang.org/packages/joneshf/elm-proof/latest/Equality#cast\n[Equal a b]: http://package.elm-lang.org/packages/joneshf/elm-proof/latest/Equality#Equal\n[Equiv a b]: http://package.elm-lang.org/packages/joneshf/elm-proof/latest/Equivalence#Equiv\n[Equivalence example]: http://package.elm-lang.org/packages/joneshf/elm-proof/latest/Equivalence#example\n[refl]: http://package.elm-lang.org/packages/joneshf/elm-proof/latest/Equality#refl\n[symmCast]: http://package.elm-lang.org/packages/joneshf/elm-proof/latest/Equality#symmCast\n",
    "aliases": [],
    "types": [
      {
        "name": "Equal",
        "comment": "\nA type that expresses two types being equal.\n\nThe only reason this works is that the value constructor is not exposed from the module.\nIf the value constructor is exposed, we end up with only being able to express equivalence.\n",
        "args": [
          "a",
          "b"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "cast",
        "comment": "\nIf we know that `a` is equal to `b`, and we have an `a`,\nthen we can get a `b`.\n",
        "type": "Equality.Equal a b -> a -> b"
      },
      {
        "name": "inj",
        "comment": "\nType equalities are injective.\n\nIf we know `a` is equal to `c`, and if we know `b` is equal to `c`,\nthen we also know `a` is equal to `b`.\n",
        "type": "Equality.Equal a c -> Equality.Equal b c -> Equality.Equal a b"
      },
      {
        "name": "refl",
        "comment": "\nType equalities are reflexive.\n\nTrivially, every type is equal to itself.\n",
        "type": "Equality.Equal a a"
      },
      {
        "name": "symm",
        "comment": "\nType equalities are symmetric.\n\nIf we know `a` is equal to `b`, then we also know `b` is equal to `a`.\n",
        "type": "Equality.Equal a b -> Equality.Equal b a"
      },
      {
        "name": "symmCast",
        "comment": "\nIf we know that `a` is equal to `b`, and we have a `b`,\nthen we can get an `a`.\n",
        "type": "Equality.Equal a b -> b -> a"
      },
      {
        "name": "symmInj",
        "comment": "\nType equalities are injective in a symmetric way.\n\nIf we know `a` is equal to `b`, and if we know `a` is equal to `c`,\nthen we also know `b` is equal to `c`.\n",
        "type": "Equality.Equal a b -> Equality.Equal a c -> Equality.Equal b c"
      },
      {
        "name": "trans",
        "comment": "\nType equalities are transitive.\n\nIf we know `a` is equal to `b`, and if we know `b` is equal to `c`,\nthen we also know `a` is equal to `c`.\n",
        "type": "Equality.Equal a b -> Equality.Equal b c -> Equality.Equal a c"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Equivalence",
    "comment": "\nA module providing primitives for proving type equivalence.\n\n@docs Equiv, refl, symm, trans\n\n# Example\n\nWe can motivate this module by stealing the example from [elm-proxy][].\nWe've got different permission levels in our program that we want to enforce:\n\n```elm\ntype Permissions\n  = User\n  | Mod\n  | Admin\n```\n\nThe simple thing to do is throw this into a field in a `Model`:\n\n```elm\ntype alias Model =\n  { name : String\n  , permissions : Permissions\n  }\n```\n\nBut, then elm gives us no help when we mess up:\n\n```elm\nview : Model -> Html Msg\nview model =\n  case model.permissions of\n    User ->\n      viewUser\n\n    Mod ->\n      viewAdmin\n\n    Admin ->\n      viewMod\n\nviewUser : Html msg\nviewUser =\n  text \"Welcome friend!\"\n\nviewMod : Html Msg\nviewMod =\n  button [ onClick Mod ]\n    [ text \"Warn all users\" ]\n\nviewAdmin : Html Msg\nviewAdmin =\n  button [ onClick Admin ]\n    [ text \"Delete all users\" ]\n```\n\nElm happily compiles this program, and the `Mod`s can now delete all the users while the `Admin`s can't do anything to stop them!\n\nWith the solution proposed by [elm-proxy][] we have compile time guarantees that we can't accidentally use `Mod` as a `User` or some such. It's a very light weight start to getting more confidence in our codebase.\n\nFor all its good, it has one important drawback.\nIf we're not careful, we can [`reproxy`][reproxy] to an illegal state.\nSo while [elm-proxy][] is a great first step toward ensuring some confidence in our program, it's just that: a first step.\nLet's take another step :).\n\n## Equivalences\n\nWe want to take a slightly different approach to solving this problem than [elm-proxy][].\nWe want to use type equivalences as proofs rather than passing around dummy arguments.\n\nType equivalences are represented here as a pair of functions between two types.\nThe definition, is exactly that:\n\n```elm\ntype alias Equiv a b =\n  (a -> b, b -> a)\n```\n\nWe are stating that `a` is equivalent to `b` when we have a function that maps `a`s to `b`s and a function that maps `b`s to `a`s.\n\nWe can use `Equiv a b` to express the differences in each permission of our program.\n\nAgain, let's start by bumping our value level permission constructors to the type level:\n\n```elm\ntype User\n  = User\n\ntype Mod\n  = Mod\n\ntype Admin\n  = Admin\n```\n\nNow that we have different types, let's talk about how we want to use the types.\nWe'd like to be able to have each view depend on the permission level and send messages of the same level as well.\nWe want functions with the types like: `User -> Html User`, `Mod -> Html Mod`, and `Admin -> Html Admin`.\nLet's define these:\n\n```elm\nviewUser : User -> Html User\nviewUser User =\n  text \"Welcome friend!\"\n\nviewMod : Mod -> Html Mod\nviewMod Mod =\n  button [ onClick Mod ]\n    [ text \"Warn all users\" ]\n\nviewAdmin : Admin -> Html Admin\nviewAdmin Admin =\n  button [ onClick Admin ]\n    [ text \"Delete all users\" ]\n```\n\nThose value level constructors are a bit weird.\nLet's rename them:\n\n```elm\ntype User\n  = Comment\n\ntype Mod\n  = Warn\n\ntype Admin\n  = Delete\n\nviewUser : User -> Html User\nviewUser Comment =\n  text \"Welcome friend!\"\n\nviewMod : Mod -> Html Mod\nviewMod Warn =\n  button [ onClick Warn ]\n    [ text \"Warn all users\" ]\n\nviewAdmin : Admin -> Html Admin\nviewAdmin Delete =\n  button [ onClick Delete ]\n    [ text \"Delete all users\" ]\n```\n\nThat's a little better :).\n\nNow that we have views for each individual permission level we'll need some way to combine each view into one top-level view.\nThe way that will play out will make more sense if we define our model first.\n\n## Defining the model\n\nThink about what we want.\nWe want to express that the permissions are exactly one of three levels.\nOur model should not be a record, as records do not model exclusive cases.\nWe should model this as a union type with each case holding the appropriate type we want each case to handle:\n\n```elm\ntype Model\n  = ModelUser User { name : String }\n  | ModelMod Mod { name : String }\n  | ModelAdmin Admin { name : String }\n```\n\nHowever, this just puts us in the same boat as the [elm-proxy][] solution.\nWe want to express at the type level that, \"No matter what case in the model we're looking at, we only use the appropriate view function\".\nWe need to lift up to the type level what each case contains.\nIn some sense, we want to \"index\" the model based on the type it contains.\n\nFor example, in the `ModelUser` case, we want to \"index\" it based on the fact that it is a `User`.\nBut elm doesn't let us express that concept clearly, we have to fake it with type equivalences:\n\n```elm\ntype Model permissions\n  = ModelUser (Equiv permissions User) { name : String }\n  | ModelMod (Equiv permissions Mod) { name : String }\n  | ModelAdmin (Equiv permissions Admin) { name : String }\n```\n\nWe are expressing that whatever case the `Model permissions` takes on has a proof of its equivalence in the respective case.\n\nIt might make more sense if we look at how we can construct one of these cases.\nTo make a `ModelUser`, we need to provide it two things:\n\n1. An equivalence between some `permissions` and `User`.\n1. A record with a `name` field that is a `String`.\n\nThe latter part is easy:\n\n```elm\nmodelUser =\n  ModelUser _ { name = \"Pat\" }\n```\n\nBut what can we provide as the equivalence?\nThat's up to us to decide!\nWe need a pair of functions that go from `permissions -> User` and `User -> permissions`.\nThe first function is easy—we could always return `Comment`.\nThe second function is harder (actually it's impossible in general for all `permissions`).\n\nRather than trying to think through what possible implementations we can make, let's instead think about the type we want `modelUser` to have.\nWe're trying to construct a `Model User`, so that's the type we want `modelUser` to have!\n\n```elm\nmodelUser : Model User\nmodelUser =\n  ModelUser _ { name = \"Pat\" }\n```\n\nSince we've chosen a **specific** `permissions`—namely `User`—we have all the information we need.\nWe have specified that we want the equivalence to have the type `Equiv User User`.\nIn other words, we need to provide a pair of functions with type `User -> User` and `User -> User`.\nWell that's easy, just return the argument in each case:\n\n```elm\nmodelUser : Model User\nmodelUser =\n  ModelUser (\\x -> x, \\x -> x) { name = \"Pat\" }\n```\n\nSo, we've manage to construct a \"proof\" that we have a \"model\" with \"permissions\" equivalent to \"User\".\nCool!\n\nSince this case is so common, this library provides an equivalence between the same type like we've defined up above: [`refl : Equiv a a`][refl].\n\n# Defining the Unified View Function\n\nNow, we can move on to displaying our model in a unified way.\nWe want to be able to say that for any `Model permissions` we're given, we can convert it to an `Html permissions`:\n\n```elm\nview : Model permissions -> Html permissions\n```\n\nLet's start implementing it, taking it one case at a time:\n\n```elm\nview : Model permissions -> Html permissions\nview model =\n  case model of\n    ModelUser eq record ->\n      viewUser Comment\n    _ ->\n      text \"\"\n```\n\nIf we attempt to compile this, we end up getting an error.\nElm is rightly inferring that the type is actually `Model permissions -> Html User`.\nWe've stated that in the `ModelUser` case we want to return an `Html User`.\nBut we've annotated the type as returning an `Html permissions`.\n\nThis is great!\nWe still have the ability to say that we will not accidentally return the wrong thing.\nAnd we cannot return any particular html value, we have to return one with `permissions` that match the `permissions` of the model.\n\nWhat we need is a way to change the `Html User` to `Html permissions`.\nThankfully, `Html.App` provides a function `map : (a -> b) -> Html a -> Html b`.\nSo, if we can find a function `User -> permissions`, we can use `map` to get the type we want.\nWe have a `Model permissions`, and the case we're in is the `ModelUser` case.\nThat means we have an `Equiv permissions User`.\nAnd remember that `Equiv permissions User` is just an alias for `(permissions -> User, User -> permissions)`.\n\nWe're carrying around just the very function we're looking for!\nHow lucky, ;).\n\n```elm\nview : Model permissions -> Html permissions\nview model =\n  case model of\n    ModelUser (to, from) record ->\n      Html.App.map from (viewUser Comment)\n    _ ->\n      text \"\"\n```\n\nAnd we can fill in the rest of the function:\n\n```elm\nview : Model permissions -> Html permissions\nview model =\n  case model of\n    ModelUser (to, from) record ->\n      Html.App.map from (viewUser Comment)\n\n    ModelMod (to, from) record ->\n      Html.App.map from (viewMod Warn)\n\n    ModelAdmin (to, from) record ->\n      Html.App.map from (viewAdmin Delete)\n```\n\nSo, where are we now?\nCan we still accidentally mess up and use the wrong view function:\n\n```elm\nview : Model permissions -> Html permissions\nview model =\n  case model of\n    ModelUser (to, from) record ->\n      Html.App.map from (viewUser Comment)\n\n    ModelMod (to, from) record ->\n      Html.App.map from (viewAdmin Delete)\n\n    ModelAdmin (to, from) record ->\n      Html.App.map from (viewMod Warn)\n```\n\nIf we try to compile this, we get an error that `map` is given the wrong argument.\nIt's expecting an `Html Mod` but receiving an `Html Admin` or vice versa.\nThis is because we have `from : Mod -> permissions` and not `from : Admin -> permissions` or whatever.\nSo each case carries with it only the equivalence it can use, and not some other equivalence.\n\n## Success!!\n\nWe did it!\nWe made a type level assertion that we wanted to only display the appropriate view in each case, and elm made sure we didn't mess up!\n\nOf course, this solution isn't perfect, but it's safer than the [elm-proxy][] solution!\n\nWhat if we try to be malicious and provide a different `from` function?\n\n```elm\nview : Model permissions -> Html permissions\nview model =\n  case model of\n    ModelUser (to, from) record ->\n      Html.App.map from (viewUser Comment)\n\n    ModelMod (to, from) record ->\n      let\n        malicious : Admin -> permissions\n        malicious _ =\n          from Warn\n      in\n        Html.App.map malicious (viewAdmin Delete)\n\n    ModelAdmin (to, from) record ->\n      let\n        malicious : Mod -> permissions\n        malicious _ =\n          from Delete\n      in\n        Html.App.map malicious (viewMod Warn)\n```\n\nWell first of all, that won't typecheck, as there's no sense of type variable scoping in elm.\nBut, assuming we comment out the type signatures, it'll type check fine.\nSounds kind of bad initially.\nBut think about it in depth a bit more.\n\nThis malicious function allows the view to be displayed, but any `permissions` coming from said view are still being translated into the appropriate level.\nMeaning, that even if a `Mod` can see what an `Admin` sees, they can't actually do any of the actions that view says they can.\n\nIn other words, if a `Mod` had this \"malicious\" view, they would see a button that said \"Delete all users\".\nBut when they press the button, they would only be warning users not deleting them.\nObviously that's bad for its own reasons, but this example was contrived anyway :).\n\nWe still have a guarantee that each level respects their permission level.\nAnd really that's all we wanted to begin with.\n\n## Finally\n\nAfter a little clean up, we have the following solution:\n\n```elm\ntype User\n  = Comment\n\ntype Mod\n  = Warn\n\ntype Admin\n  = Delete\n\ntype Model permissions\n  = ModelUser (Equiv permissions User) { name : String }\n  | ModelMod (Equiv permissions Mod) { name : String }\n  | ModelAdmin (Equiv permissions Admin) { name : String }\n\nmodelUser : String -> Model User\nmodelUser name =\n  ModelUser refl { name = name }\n\nmodelMod : String -> Model Mod\nmodelMod name =\n  ModelMod refl { name = name }\n\nmodelAdmin : String -> Model Admin\nmodelAdmin name =\n  ModelAdmin refl { name = name }\n\nview : Model permissions -> Html permissions\nview model =\n  case model of\n    ModelUser (_, from) record ->\n      Html.App.map from (viewUser Comment)\n\n    ModelMod (_, from) record ->\n      Html.App.map from (viewMod Warn)\n\n    ModelAdmin (_, from) record ->\n      Html.App.map from (viewAdmin Delete)\n\nviewUser : User -> Html User\nviewUser Comment =\n  text \"Welcome friend!\"\n\nviewMod : Mod -> Html Mod\nviewMod Warn =\n  button [ onClick Warn ]\n    [ text \"Warn all users\" ]\n\nviewAdmin : Admin -> Html Admin\nviewAdmin Delete =\n  button [ onClick Delete ]\n    [ text \"Delete all users\" ]\n```\n\n[elm-proxy]: http://package.elm-lang.org/packages/joneshf/elm-proxy/latest\n[Proxy]: http://package.elm-lang.org/packages/joneshf/elm-proxy/latest/Proxy#Proxy\n[permissions]: https://github.com/joneshf/elm-proof/tree/master/examples/permissions\n[refl]: http://package.elm-lang.org/packages/joneshf/elm-proof/latest/Equivalence#refl\n[reproxy]: http://package.elm-lang.org/packages/joneshf/elm-proxy/latest/Proxy#reproxy\n\n",
    "aliases": [
      {
        "name": "Equiv",
        "comment": "\nWe represent type equivalence by a type isomorphism.\n\nIf we want to say two types are equivalent,\nwe need to provide a way to convert between them.\n\nN.B. This is different from type equality in important ways.\nFor more information, see:\nParametricity, Type Equality and Higher-order Polymorphism (Vytiniotis, Weirich)\nhttp://repository.upenn.edu/cgi/viewcontent.cgi?article=1675&context=cis_papers\n",
        "args": [
          "a",
          "b"
        ],
        "type": "( a -> b, b -> a )"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "refl",
        "comment": "\nType equivalences are reflexive.\n\nEvery type is equivalent to itself.\n\nThat is to say:\n`Int` is equivalent to `Int`,\n`Maybe a` is equivalent to `Maybe a`,\nand so on.\n",
        "type": "Equivalence.Equiv a a"
      },
      {
        "name": "symm",
        "comment": "\nType equivalences are symmetric.\n\nIf we know `a` is equivalent to `b`, then we also know `b` is equivalent to `a`.\n",
        "type": "Equivalence.Equiv a b -> Equivalence.Equiv b a"
      },
      {
        "name": "trans",
        "comment": "\nType equivalences are transitive.\n\nIf we know `a` is equivalent to `b`, and if we know `b` is equivalent to `c`,\nthen we also know `a` is equivalent to `c`.\n",
        "type": "Equivalence.Equiv a b -> Equivalence.Equiv b c -> Equivalence.Equiv a c"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  }
]