[
  {
    "name": "Updater",
    "comment": " Helps you to more easily organize and update nested child components.\n    The usual boilerplate has been reduced drastically.\n\nSee the `/examples` folder for usage examples.\n\n@docs Interface, converter, Converter, Updater, toCmd, noReaction\n\n",
    "aliases": [
      {
        "name": "Converter",
        "comment": " Converters are functions that take a child component's message and converts it\ninto the parent message that handles `Updater`s. To use a Converter, just `map` it onto\nany instance of a child's message.\n\nYou can use the same converter for anything that takes a message and has a `map` function:\n* use it in `subscription` with `Sub.map`\n* use it in `view` with `Html.map`\n* use it in `init` and `update` with `Cmd.map`\n\nSo, supposing you were displaying a `Timer` component in your view, and you had a \n`Converter Msg Timer.Msg` named `timer1C`, you could do this in your view function:\n\n```elm\nview model =\n  div [] [...\n         , Html.map timer1C <| Timer.view model.timer1\n         ... ]\n```\nYou can also use it to issue commands to child components within a parent's `update` function.\nFor example, suppose `Timer.Reset` is part of `Timer.Msg`:\n\n```elm\nupdate msg model =\n  case msg of\n    ...\n    ResetTimer -> model ! [ Cmd.map timer1C <| toCmd Timer.Reset ]\n```\n",
        "args": [
          "pMsg",
          "cMsg"
        ],
        "type": "cMsg -> pMsg"
      },
      {
        "name": "Interface",
        "comment": " An Interface describes how to communicate between a parent and child component.\nYou must supply four functions:\n* `get` - retrieves the child component model from the parent's model.\n* `set` - takes the child model and parent model, and returns the parent model with the updated child model.\n* `update` - the standard update function for the component.\n* `react` - a function that allows the parent to react to any messages that occur in the child component. Its arguments are the child's message, the child's updated model, and the parent's updated model.\n",
        "args": [
          "pModel",
          "pMsg",
          "cModel",
          "cMsg"
        ],
        "type": "{ get : pModel -> Maybe.Maybe cModel , set : cModel -> pModel -> pModel , update : cMsg -> cModel -> ( cModel, Platform.Cmd.Cmd cMsg ) , react : cMsg -> cModel -> pModel -> ( pModel, Platform.Cmd.Cmd pMsg ) }"
      },
      {
        "name": "Updater",
        "comment": " You need to create one message in the parent component that takes an `Updater` as\n  an argument. This one message will handle all the internal updating for all of your\n  child components.\n\nFor example:\n```elm\ntype Msg = Increment\n         | SetTo Int\n         | UpdaterMsg (Updater Model Msg)\n```\nThen, in your `update` function:\n```elm\nupdate : Msg -> Model -> ( Model, Cmd Msg )\nupdate msg model =\n  case msg of\n      Increment -> ...\n\n      SetTo n -> ...\n\n      UpdaterMsg u -> u model\n```\nAn `Updater` is a function automatically generated by converters, constructed with a child's \nmessage and an Interface for handling a child's type. Feed the parent's model into an\n`Updater` and it will pop out a model with the updated child.\n",
        "args": [
          "pModel",
          "pMsg"
        ],
        "type": "pModel -> ( pModel, Platform.Cmd.Cmd pMsg )"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "converter",
        "comment": "\n`converter` creates a `Converter`. It's first argument is the Msg constructor that \nhandles Updaters. The second argument is the `Interface` to the child component.\n\nFor example. let's say our parent's Model and Msg are these:\n```elm\ntype alias Model = { timer1 : Timer.Model\n                   , ...}\n\ntype Msg = UpdaterMsg (Updater Model Msg)\n```\nTo make a Converter for timer1:\n\n```elm\ntimer1C : Converter Msg Timer.Msg\ntimer1C = converter\n          UpdaterMsg\n          { get = Just << .timer1\n          , set = (\\ cm m -> { m | timer1 = cm } )\n          , update = Timer.update\n          , react = noReaction }\n```\nThen you can use `map` and `timer1C` to converter any Timer messages.\n\nWhat if you have multiple Timer models stored in a dictionary `Dict Int Timer.Model`, which is stored in your model at `model.timers`?\n\n```elm\ntimerC : Int -> Converter Msg Timer.Msg\ntimerC n = converter\n           UpdaterMsg\n           { get = (\\ model -> Dict.get n model.timers )\n           , set = (\\ cModel pModel -> { pModel | timers =\n                                             Dict.insert n cModel pModel.timers } )\n           , update = Timer.update\n           , react = noReaction }\n```\nThen you can use something like `map (timerC 4) ...` to convert any messages for the\ntimer with the id of `4`. \n",
        "type": "Updater.UpdaterMsg pModel pMsg -> Updater.Interface pModel pMsg cModel cMsg -> Updater.Converter pMsg cMsg"
      },
      {
        "name": "noReaction",
        "comment": " use in an `Interface` for `react` when you don't want to react to any of the child's messages. ",
        "type": "cMsg -> cModel -> pModel -> ( pModel, Platform.Cmd.Cmd pMsg )"
      },
      {
        "name": "toCmd",
        "comment": " Convenience function to convert a message into a Cmd.\nIt's useful for emitting commands in the `react` function.\n\nBe careful that you don't create any Cmd message loops!\n",
        "type": "msg -> Platform.Cmd.Cmd msg"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  }
]