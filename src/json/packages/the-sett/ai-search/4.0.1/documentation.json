[
  {
    "name": "Search",
    "comment": "\n\n\n# Input types for searches:\n\n@docs Step, Uninformed, Informed, WithUninformed\n\n\n# The search output type:\n\n@docs SearchResult\n\n\n# Helper functions for iterating searches to produce results:\n\n@docs next, nextN, nextGoal\n\n\n# Uninformed search strategies:\n\n@docs breadthFirst, depthFirst, depthBounded, costBounded, uniformCost\n@docs iterativeDeepening, iterativeCostIncreasing\n\n\n# Informed search strategies:\n\n@docs aStar, greedy, fBounded\n\n",
    "aliases": [
      {
        "name": "Informed",
        "comment": " Defines the type of a bundle of operators that need to be supplied to conduct\nan informed (heuristic) search.\n",
        "args": [
          "state"
        ],
        "type": "{ step : Search.Step state , cost : state -> Float , heuristic : state -> Float }"
      },
      {
        "name": "Step",
        "comment": " Defines the type of the step function that produces new states from existing\nones. This is how the graph over the search space is defined. The step function\ntakes a state and provides a list of other states that can be reached from it.\nEach of the listed states is paired with a Bool that when true indiciates that\na state is considered to be a goal of the search.\n",
        "args": [
          "state"
        ],
        "type": "state -> List ( state, Bool )"
      },
      {
        "name": "Uninformed",
        "comment": " Defines the type of a bundle of operators that need to be supplied to conduct\nan uninformed (non-heuristic) search.\n",
        "args": [
          "state"
        ],
        "type": "{ step : Search.Step state, cost : state -> Float }"
      },
      {
        "name": "WithUninformed",
        "comment": " Defines the type of a bundle of operators that need to be supplied to conduct\nan uninformed (non-heuristic) search. This is an extensible record so that\nheuristic searches can also have this type since they use the same cost and step\nfunctions. This makes it easy to switch from a heuristic to anon-heuristic search.\n",
        "args": [
          "a",
          "state"
        ],
        "type": "{ a | step : Search.Step state, cost : state -> Float }"
      }
    ],
    "types": [
      {
        "name": "SearchResult",
        "comment": " Defines the possible outcomes of a search. A search may produce the following\nresults:\n\n  - Complete. The search space has been exhausted without finding a goal state.\n  - Goal. A goal state has been found. A function to find further results is also\n    returned, in order that the search may be continued to find more goals.\n  - Ongoing. A goal state has not been found yet. The state most recently examined\n    is returned along with a function to continue to the search.\n\n",
        "args": [
          "state"
        ],
        "cases": [
          [
            "Complete",
            []
          ],
          [
            "Goal",
            [
              "state",
              "() -> Search.SearchResult state"
            ]
          ],
          [
            "Ongoing",
            [
              "state",
              "() -> Search.SearchResult state"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "aStar",
        "comment": " Performs an A* search. This is one that always follows the search node that\nhas the highest f value (f = heuristic + cost).\nThe seach will only be optimal if the heuristic function is monotonic.\n",
        "type": "Search.Informed state -> List state -> Search.SearchResult state"
      },
      {
        "name": "breadthFirst",
        "comment": " Performs an unbounded breadth first search. Breadth first searches store\na lot of pending nodes in the buffer, so quickly run out of space.\n",
        "type": "Search.WithUninformed a state -> List state -> Search.SearchResult state"
      },
      {
        "name": "costBounded",
        "comment": " Implements a cost bounded search. This search will proceed depth first.\n",
        "type": "Search.WithUninformed a state -> Float -> List state -> Search.SearchResult state"
      },
      {
        "name": "depthBounded",
        "comment": " Implements an uninformed search that is bounded to a specified maximum depth.\n",
        "type": "Search.WithUninformed a state -> Int -> List state -> Search.SearchResult state"
      },
      {
        "name": "depthFirst",
        "comment": " Performs an unbounded depth first search. Depth first searches can easily\nfall into infinite loops.\n",
        "type": "Search.WithUninformed a state -> List state -> Search.SearchResult state"
      },
      {
        "name": "fBounded",
        "comment": " Implements an f value (f = heuristic + cost) bounded search. This search will\nproceed depth first.\n",
        "type": "Search.Informed state -> Float -> List state -> Search.SearchResult state"
      },
      {
        "name": "greedy",
        "comment": " Performs a greedy heuristic search. This is one that always follows the\nsearch node that has the highest h value (h = heuristic).\n",
        "type": "Search.Informed state -> List state -> Search.SearchResult state"
      },
      {
        "name": "iterativeCostIncreasing",
        "comment": " Implements an iterative cost increasing search. This search proceed depth first\nbut repeats at progressively larger cost limits. The iteration number is\nmultiplied by a specified multiple to calculate the maximum cost allowed\nat a given iteration.\n",
        "type": "Float -> Search.WithUninformed a state -> List state -> Search.SearchResult state"
      },
      {
        "name": "iterativeDeepening",
        "comment": " Implements an iterative deepening search. This search proceed depth first\nbut repeats at progressively larger depth limits. The iteration number is\nmultiplied by a specified multiple to calculate the maximum depth allowed\nat a given iteration.\n",
        "type": "Int -> Search.WithUninformed a state -> List state -> Search.SearchResult state"
      },
      {
        "name": "next",
        "comment": " Steps a search result, to produce the next result.\n\n  - The result of this function may be an Ongoing search. This will provide the\n    current head search node and a continuation to run the remainder of the search.\n\n",
        "type": "Search.SearchResult state -> Search.SearchResult state"
      },
      {
        "name": "nextGoal",
        "comment": " Continues a search result, to produce the next search goal.\n\n  - The result of this function will never be an Ongoing search. This\n    function will recursively apply the search until either a Goal state is\n    found or the walk over the search space is Complete.\n  - If the search is insufficiently constrained and no goal can ever be found,\n    this function may infnite loop.\n\n",
        "type": "Search.SearchResult state -> Search.SearchResult state"
      },
      {
        "name": "nextN",
        "comment": " Continues a search result, to produce the next search goal up to a limited\nnumber of iterations.\n\n  - This function will recursively apply the search until either a Goal state\n    is found or the walk over the search space is Complete, or the iteration\n    count is exhausted in which case an Ongoing search may be returned.\n\n",
        "type": "Int -> Search.SearchResult state -> Search.SearchResult state"
      },
      {
        "name": "uniformCost",
        "comment": " Performs a uniform-cost search. This always follows the search node that\nhas the lowest path cost. It is called a uniform cost search because the\nboundary of the search will have a roughly uniform cost as the search\nspace is searched by increasing cost.\n",
        "type": "Search.WithUninformed a state -> List state -> Search.SearchResult state"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  }
]