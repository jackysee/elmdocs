[
  {
    "name": "Array.Extra",
    "comment": " Convenience functions for working with Array\n\n# Transformations\n@docs update, sliceFrom, sliceUntil\n\n# Higher order helpers\n@docs filterMap, apply, map2, map3, map4, map5, removeWhen\n\n# Zips\n@docs zip, zip3, zip4, zip5\n\n# Slicing / resizing\n@docs resizelRepeat, resizerRepeat, resizelIndexed, resizerIndexed, splitAt, removeAt\n\n# Unsafe\n@docs getUnsafe\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "apply",
        "comment": " Apply an array of functions to an array of values.\n",
        "type": "Array.Array (a -> b) -> Array.Array a -> Array.Array b"
      },
      {
        "name": "filterMap",
        "comment": " Apply a function that may succeed to all values in the array, but only keep the successes.\n\n    String.toInt : String -> Maybe Int\n    filterMap String.toInt (fromList [\"3\", \"4.0\", \"5\", \"hats\"]) == fromList [3,5]\n",
        "type": "(a -> Maybe.Maybe b) -> Array.Array a -> Array.Array b"
      },
      {
        "name": "getUnsafe",
        "comment": " Unsafe version of get, don't use this unless you know what you're doing!\n",
        "type": "Int -> Array.Array a -> a"
      },
      {
        "name": "map2",
        "comment": " Combine two arrays, combining them with the given function.\nIf one array is longer, the extra elements are dropped.\n\n    map2 (+) [1,2,3] [1,2,3,4] == [2,4,6]\n    map2 (,) [1,2,3] ['a','b'] == [ (1,'a'), (2,'b') ]\n    pairs : Array a -> Array b -> Array (a,b)\n    pairs lefts rights =\n        map2 (,) lefts rights\n",
        "type": "(a -> b -> result) -> Array.Array a -> Array.Array b -> Array.Array result"
      },
      {
        "name": "map3",
        "comment": " ",
        "type": "(a -> b -> c -> result) -> Array.Array a -> Array.Array b -> Array.Array c -> Array.Array result"
      },
      {
        "name": "map4",
        "comment": " ",
        "type": "(a -> b -> c -> d -> result) -> Array.Array a -> Array.Array b -> Array.Array c -> Array.Array d -> Array.Array result"
      },
      {
        "name": "map5",
        "comment": " ",
        "type": "(a -> b -> c -> d -> e -> result) -> Array.Array a -> Array.Array b -> Array.Array c -> Array.Array d -> Array.Array e -> Array.Array result"
      },
      {
        "name": "removeAt",
        "comment": " Remove the element at the given index\n",
        "type": "Int -> Array.Array a -> Array.Array a"
      },
      {
        "name": "removeWhen",
        "comment": " Take a predicate and an array, return an array that contains elements which fails to satisfy the predicate.\n    This is equivalent to `Array.filter (not << predicate) list`\n\n    removeWhen isEven [1,2,3,4] == [1,3]\n",
        "type": "(a -> Bool) -> Array.Array a -> Array.Array a"
      },
      {
        "name": "resizelIndexed",
        "comment": " Resize an array from the left, padding the right-hand side with the given index function.\n",
        "type": "Int -> (Int -> a) -> Array.Array a -> Array.Array a"
      },
      {
        "name": "resizelRepeat",
        "comment": " Resize an array from the left, padding the right-hand side with the given value.\n",
        "type": "Int -> a -> Array.Array a -> Array.Array a"
      },
      {
        "name": "resizerIndexed",
        "comment": " Resize an array from the right, padding the left-hand side with the given index function.\n",
        "type": "Int -> (Int -> a) -> Array.Array a -> Array.Array a"
      },
      {
        "name": "resizerRepeat",
        "comment": " Resize an array from the right, padding the left-hand side with the given value.\n",
        "type": "Int -> a -> Array.Array a -> Array.Array a"
      },
      {
        "name": "sliceFrom",
        "comment": " Drop *n* first elements from an array. In other words, slice an array from an index until the very end. Given negative argument, count the end of the slice from the end of the array.\n\n    sliceFrom  5 (fromList [0..9]) == fromList [5,6,7,8,9]\n    sliceFrom -3 (fromList [0..9]) == fromList [7,8,9]\n",
        "type": "Int -> Array.Array a -> Array.Array a"
      },
      {
        "name": "sliceUntil",
        "comment": " Take *n* first elements from an array. In other words, slice an array from the very beginning until index not including. Given negative argument, count the beginning of the slice from the end of the array.\n\n    sliceUntil  5 (fromList [0..9]) == fromList [0,1,2,3,4]\n    sliceUntil -3 (fromList [0..9]) == fromList [0,1,2,3,4,5,6]\n",
        "type": "Int -> Array.Array a -> Array.Array a"
      },
      {
        "name": "splitAt",
        "comment": " Split an array into two arrays, the first ending at and the second starting at the given index\n",
        "type": "Int -> Array.Array a -> ( Array.Array a, Array.Array a )"
      },
      {
        "name": "update",
        "comment": " Update the element at the index using a function. Returns the array unchanged if the index is out of bounds.\n\n    update  1 ((+)10) (fromList [1,2,3]) == fromList [1,12,3]\n    update  4 ((+)10) (fromList [1,2,3]) == fromList [1,2,3]\n    update -1 ((+)10) (fromList [1,2,3]) == fromList [1,2,3]\n",
        "type": "Int -> (a -> a) -> Array.Array a -> Array.Array a"
      },
      {
        "name": "zip",
        "comment": " Zip arrays into tuples\n",
        "type": "Array.Array a -> Array.Array b -> Array.Array ( a, b )"
      },
      {
        "name": "zip3",
        "comment": " ",
        "type": "Array.Array a -> Array.Array b -> Array.Array c -> Array.Array ( a, b, c )"
      },
      {
        "name": "zip4",
        "comment": " ",
        "type": "Array.Array a -> Array.Array b -> Array.Array c -> Array.Array d -> Array.Array ( a, b, c, d )"
      },
      {
        "name": "zip5",
        "comment": " ",
        "type": "Array.Array a -> Array.Array b -> Array.Array c -> Array.Array d -> Array.Array e -> Array.Array ( a, b, c, d, e )"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  }
]