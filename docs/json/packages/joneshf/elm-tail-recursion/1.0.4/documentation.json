[
  {
    "name": "TailRecursion",
    "comment": "\n# Table of Contents\n\n1. [Functions](#functions)\n1. [Design](#design)\n  1. [The `recurse` function](#the-recurse-recurse-function)\n1. [Example](#example)\n  1. [Mutual Recursion](#mutual-recursion)\n  1. [Direct Recursion](#direct-recursion)\n  1. [Using `recurse`](#using-recurse-recurse-)\n  1. [Nota Bene](#nota-bene)\n  1. [Put it All Together](#put-it-all-together)\n\n## Functions\n@docs recurse\n\n## Design\n\n### The [`recurse`][recurse] function\n\nLet's start with an explanation for how this function works.\n\nThanks to purity and fast-and-loose reasoning,\nwe have exactly one way to implement this function.\n\nThe only way to get a `b` is to apply an `a` to `a -> Result b a`.\nIf the result of application is `Ok a`,\nwe still don't have a `b` and must apply this new `a` to `a -> Result b a`.\nAt some point we get a value `Err b`, and thus we can finally end the recursion.\n\nYou might be wondering, \"Why is this modeled with `Result b a`?\"\nLet's think about how else we could model this function.\nWe want to know if we should continue recursing or if we should stop.\nWe could introduce our own type like:\n\n```elm\ntype Step a b\n  = Stop a\n  | Recurse b\n```\n\nThe type of `recurse` would then become `(a -> Step b a) -> a -> b`.\nThe implementation would be almost exactly the same save for some renaming.\nSo, why not make this move?\n\nOne reason not to make this move is because it forces an additional API onto the use of this function.\nEverybody that uses `recurse` has to now learn about `Step a b`.\nThey have to learn what value constructors exist.\nThey have to learn what functions operate on the type.\nThat seems like a bit too much to ask a user of this function.\nUntil elm figures out a story for shared vocabulary that doesn't involve convention,\nwe'll always have this trade-off to consider.\n\nAnother reason not to make this move is because it forces us to maintain a type that is isomorphic to `Result a b`.\nAny function we could think to write either already has been written for `Result a b`,\nor it should be written and pushed to the `Result` module, the `Result.Extra` module, or some other central location.\nWhich begs the question as to whether this [`recurse`][recurse] function deserves its own module or not...\nIn any case, as maintainers, we get absolutely no benefit from adding `Step a b`.\n\nRather than force those burdens, we chose to use `Result a b`.\nthe user doesn't have to learn anything new and we don't have to maintain `ResultJr a b`.\n\n## Example\n\nA simple example is in order.\nWhen writing mutually recursive functions,\nelm compiles to code that can blow the stack.\nMutual recursion isn't the only place we can get a benefit here,\nso don't read too much into the example.\n\n### Mutual Recursion\nFor instance, the following functions can blow the stack:\n\n```elm\neven : Int -> Bool\neven n =\n  case n of\n    0 ->\n      True\n    _ ->\n      odd (n - 1)\n\nodd : Int -> Bool\nodd n =\n  case n of\n    0 ->\n      False\n    _ ->\n      even (n - 1)\n```\n\nThese functions are fine for small positive values.\nBut if we apply a large `Int` (like `1000000`), elm will throw a runtime exception.\n\nThis example is trivial and contrived for a reason.\nThere are multiple ways to solve this problem better, but that's not the purpose of it.\nThe purpose is to show that even a simple pair of mutually recursive functions can cause runtime errors with elm.\n\n### Direct Recursion\n\nWe can write this tail recursively by just inlining the body of both mutual recursions.\n\n```elm\neven : Int -> Bool\neven n =\n  case n of\n    0 ->\n      True\n    _ ->\n      case (n - 1) of\n        0 ->\n          False\n        _ ->\n          even ((n - 1) - 1)\n\nodd : Int -> Bool\nodd n =\n  case n of\n    0 ->\n      False\n    _ ->\n      case (n - 1) of\n        0 ->\n          True\n        _ ->\n          odd ((n - 1) - 1)\n```\n\nAfter a bit of cleanup, it's even understandable!\n\n```elm\neven : Int -> Bool\neven n =\n  case n of\n    0 ->\n      True\n    1 ->\n      False\n    _ ->\n      even (n - 2)\n\nodd : Int -> Bool\nodd n =\n  case n of\n    0 ->\n      False\n    1 ->\n      True\n    _ ->\n      odd (n - 2)\n```\n\nA very clean and elegant solution, but a solution that removes the inherent mutual recursion of the original.\nEvery problem we face with mutual recursion isn't always so easily changed.\nPerhaps even more important is that converting mutual recursion to direct recursion can't always happen.\n\n### Using [`recurse`][recurse]\n\nThere's another solution we could have arrived at though.\nOne that keeps the mutual recursion but protects ourselves from blowing the stack.\nIf we extract the base and inductive cases out,\nwe can use [`recurse`][recurse] instead.\n\nWe need to supply a function `(a -> Result b a)` and `a` to [`recurse`][recurse].\nThe `a` will be `Int`, as that's the input type of `even`/`odd`.\nThe `b` will be `Bool`, as that's the return type of `even`/`odd`.\n\nSo we need to create a function `Int -> Result Bool Int`.\nLet's look at `even` first.\nIf the `Int` is `0`, we're done, we know what value to returnâ€”`True`.\nIf the `Int` is anything else, we're not done.\nWe need to recurse with the predecessor.\n\nSimilar logic works for the `odd` step.\n\n```elm\nevenStep : Int -> Result Bool Int\nevenStep n =\n  case n of\n    0 ->\n      Err True\n    _ ->\n      Ok (n - 1)\n\noddStep : Int -> Result Bool Int\noddStep n =\n  case n of\n    0 ->\n      Err False\n    _ ->\n      Ok (n - 1)\n```\n\n### Nota Bene\n\nIt's important to notice that we're not doing any actual recursion here.\nWe're just converting `Int`s into `Result Bool Int`.\nI think most people will agree that it's much easier to understand and test non-recursive functions\nthan recursive functions.\n\n### Put it All Together\n\nNow that we have our \"recursive\" functions, we need to put them to use with [`recurse`][recurse].\nFor the `even` function, we want to follow the ideas of our original implementation.\nWe first take an even step, and then we take an odd step.\nFor the `odd` function, we first take an odd step, and then we take an even step\nThe functions almost write themselves.\n\n```elm\neven : Int -> Bool\neven =\n  recurse <| \\n ->\n    evenStep n `Result.andThen` oddStep\n\nodd : Int -> Bool\nodd =\n  recurse <| \\n ->\n    oddStep n `Result.andThen` evenStep\n```\n\nNotice that we can lean on the our good friend `Result.andThen`.\nAll of our functions that we know and use are still applicable here.\nWe don't need to attempt to learn some new abstractions to use [`recurse`][recurse]\n\nNow if we apply `1000000` to `even`, we'll actually get a value, rather than a runtime exception!\n\n[recurse]: #recurse\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "recurse",
        "comment": "\nIf you have a non-tail recursive function,\nuse this function to ensure it won't blow the stack.\n\n## &#x26a0; &#x26a0; &#x26a0;\nThis guarantee only holds if the function you pass in does not grow the stack.\n## &#x26a0; &#x26a0; &#x26a0;\n\n```elm\ncollatz : Int -> Result Int Int\ncollatz n =\n  if n == 1 then\n    Err 1\n  else if n % 2 == 0 then\n    Ok (n // 2)\n  else\n    Ok (3 * n + 1)\n\n\nconjecture : Int -> Int\nconjecture =\n  recurse collatz\n```\n",
        "type": "(a -> Result.Result b a) -> a -> b"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  }
]